<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>LYAHFGG: Chapter 1 Starting out</title>
    <meta name="author" content="Will Price">
    <meta name="description" content="">
    <link href="http://feeds.feedburner.com/willpriceblog" type="application/atom+xml" title="Will Price" rel="alternative"/>
    <link rel="stylesheet" href="/css/base.css">
    <link rel="stylesheet" href="/css/skeleton.css">
    <link rel="stylesheet" href="/css/pygments.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto+Slab">
    <link rel="stylesheet" href="/css/layout.css">
    <link rel="stylesheet" href="/css/user.css">

    <link rel="shortcut icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png">

    <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
    <script src="/scripts/toc.js"></script>
    <script src="/scripts/ganalytics.js"></script>
    
      
      
    
      
      
    
    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="title">
        <a href="/">Will Price</a>
        <a class="extra" href="/">Posts</a>
        <!-- Notes need more cleaning up before being visible for
             browsing!
        <a class="extra" href="/notes">Notes</a>
        -->
        <a class="extra" href="/about.html">About</a>
        <hr />
      </div>
      <section>
        <p>I’ve decided to learn Haskell as from what I’ve read, it seems like an
interesting language quite different from anything I’ve used before. I’d
also very much like to be able to hack on <a href="http://xmonad.org/">XMonad</a>,
the tiling window manager I use.</p>

<p><a href="http://learnyouahaskell.com/">‘Learn you a Haskell for great good’</a> is a fantastic book written in a
light hearted manner with very good explanations and drawings to keep
your attention. It’s available to read free on the website.</p>

<h4 id="haskell">Haskell</h4>
<p>Haskell is <em>referentially transparent</em> and as such you can’t
change variables (they’re actually called <em>definitions</em> or <em>names</em> as they don’t <em>vary</em>)after assigning a value; for example you can’t say x = 5
and then saying that x = 6. This means <em>side effects</em> don’t exist (when
calling a function twice with the same parameters it might return
something different in an imperative language – not in Haskell! Variable
reassignment isn’t permitted).</p>

<p>Haskell also has the cool property of being <em>lazy</em> meaning it will only
evaluate expressions when it absolutely must, this allows us to play
with infinite sets, this is the result of referential transparency.</p>

<p>Haskell is <em>statically typed</em> meaning that Haskell knows what things are
numbers, strings, lists and so on. This allows it check for a lot of
possible errors at compile time. Whilst this might lead you to think
that you have to tell Haskell what type everything is in your program,
this is not the case. Haskell has a <em>type inference</em> system that knows
that when you perform the assignment a = 5 + 4, that a is also a number,
and so on.</p>

<h4 id="basic-operators">Basic Operators</h4>
<ul>
  <li>AND: &amp;&amp;</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>OR:</td>
          <td> </td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>NOT: not</li>
  <li>EQUIVALENCE: ==</li>
  <li>
    <p>NONEQUIVALENCE: /=</p>
  </li>
  <li>succ x: returns the <em>successor</em> of x (e.g. succ 8 = 9)</li>
  <li>min x y: returns the <em>minimum</em> of x and y (e.g. min 7 10 = 7)</li>
  <li>max x y: returns the <em>maximum</em> of x and y (e.g. max 7 10 = 10)</li>
  <li>div x y: performs integer division on x and y (e.g. div 92 10 = 9)</li>
</ul>

<p>Functions that take 2 arguments can be called as <em>infix</em> operator like
so:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">div</span> <span class="mi">92</span> <span class="mi">10</span> 
<span class="mi">9</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="mi">92</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">10</span>
<span class="mi">9</span></code></pre></figure>

<h5 id="operator-precedence">Operator Precedence</h5>
<p>The order in which operators evaluated from first to last is:</p>

<ol>
  <li>Functions</li>
  <li>Multiplication and division</li>
  <li>Addition and subtraction</li>
</ol>

<p>If operators are on the same level of precedence, for example the
expression:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">ghci</span><span class="o">&gt;</span> <span class="mi">7</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">/</span> <span class="mi">4</span>
<span class="mf">14.0</span></code></pre></figure>

<p>operators are evaluated from <strong>right to left</strong></p>

<h4 id="function-definition">Function definition</h4>
<p>Functions are defined in a very clean way in Haskell, like so:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">doubleMe</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span></code></pre></figure>

<p><em>doubleMe</em> is the function name, all the strings or characters after the name to the equals sign are parameters, parentheses are not used to bind parameters to functions like in C or Python. The expression after the equals sign is evaluated when the function is called and returned.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">doubleMe</span> <span class="mi">7</span>
<span class="mi">14</span></code></pre></figure>

<p>Also remember that definitions are also functions so ‘x = 8’ is a function that returns 8 when called and so on.</p>

<h4 id="conditionals">Conditionals</h4>
<p>Given that Haskell isn’t imperative all ‘if’s must be accompanied by an ‘else’, if the predicate evaluates to false then the function won’t know what to return otherwise.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">amIawesome</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s">"Keith Devlin"</span>
                <span class="kr">then</span> <span class="s">"Yes"</span>
                <span class="kr">else</span> <span class="s">"No, You're not Keith Devlin"</span>


<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">amIawesome</span> <span class="s">"Keith Devlin"</span>
<span class="s">"Yes"</span></code></pre></figure>

<h4 id="lists">Lists</h4>
<p>Lists are <em>homogeneous</em>. Concatenation walks through the first list before appending the other list, this is computationally intensive on big lists. Prepend lists to avoid this issue.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="s">"this"</span><span class="p">,</span><span class="s">"is"</span><span class="p">,</span><span class="s">"a"</span><span class="p">,</span><span class="s">"list"</span><span class="p">]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">list</span>
<span class="p">[</span><span class="s">"this"</span><span class="p">,</span><span class="s">"is"</span><span class="p">,</span><span class="s">"a"</span><span class="p">,</span><span class="s">"list"</span><span class="p">]</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="c1">-- General list operations</span>


<span class="c1">-- Concatenation/Appending</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>

<span class="c1">-- Prepending</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="c1">-- Accesing list elements (index starts at 0)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">3</span>
<span class="mi">15</span>

<span class="c1">-- Head, Tail, Init and Last</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="s">"hello"</span>
<span class="sc">'h'</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="s">"hello"</span>
<span class="sc">'e</span><span class="err">l</span><span class="n">lo'</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">init</span> <span class="s">"hello"</span>
<span class="sc">'h</span><span class="err">e</span><span class="n">ll'</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">last</span> <span class="s">"hello"</span>
<span class="sc">'o'</span>

<span class="c1">-- List comparisons (refer to notes above for explanation)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="kt">True</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
<span class="kt">True</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="kt">True</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">False</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="kt">False</span>

<span class="c1">-- Length</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">length</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="mi">3</span>

<span class="c1">-- null (is the list empty)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="kt">[]</span>
<span class="kt">True</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="kt">FalsE</span>

<span class="c1">-- Reverse</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1">-- Take</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">10</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">[]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">maximum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">92</span><span class="p">]</span>
<span class="mi">92</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">minimum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="mi">0</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">15</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="mi">36</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">elem</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">True</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">elem</span> <span class="mi">2</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">False</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Truce</span></code></pre></figure>

<h4 id="texas-ranges">TEXAS RANGES</h4>
<p>Texas ranges allow you to produce a list from an arithmetic sequence in any step size up to any number or it can even be infinite.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span></code></pre></figure>

<p>This shows a simple Texas range, the default step size of 1, if you wanted to create an arithmetic list with a negative common difference then you must specify the step size as Haskell defaults to one. So [20..1] would evaluate to an empty list as 20 is greater than one.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">19</span><span class="o">..</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1">-- Or you could always just reverse a list:</span>

<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">reverse</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span></code></pre></figure>

<p>As the above example shows, step size is implicitly defined by writing the second term of the sequence.</p>

<p>Any type of element that is enumerable can be used with Texas ranges. Letters for example are enumerable:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">'a'</span><span class="o">..</span><span class="sc">'z'</span><span class="p">]</span>
<span class="s">"abcdefghijklmnopqrstuvwxyz"</span></code></pre></figure>

<p>If you want to produce a list up to a certain number of members you can use ‘take’ on an infinite list:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">12</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="o">..</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">42</span><span class="p">,</span><span class="mi">48</span><span class="p">,</span><span class="mi">54</span><span class="p">,</span><span class="mi">60</span><span class="p">,</span><span class="mi">66</span><span class="p">,</span><span class="mi">72</span><span class="p">]</span></code></pre></figure>

<p>‘cycle’ and ‘repeat’ produce infinite lists which can be used with ‘take’ to produce finite lists.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">9</span> <span class="p">(</span><span class="n">cycle</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">repeat</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span></code></pre></figure>

<h4 id="list-comprehensions">LIST COMPREHENSIONS</h4>
<p>List comprehensions are very similar to set comprehensions for mathematics (note: very cool). They allow you to generate lists of elements based on predicates. The example below will show a typical list comprehension:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">example</span> <span class="n">xs</span> <span class="n">ubound</span> <span class="o">=</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">ubound</span><span class="p">)</span> <span class="p">]</span>

<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">example</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="mi">5</span> 
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span></code></pre></figure>

<p><em>example</em> refers to the name of the function and the 2 variables afterward are the parameters: ‘xs’ ‘ubound’. ‘x’ is drawn from the list ‘xs’, then the predicate ‘x &lt; ubound’ filters out the elements of the list greater than ‘ubound’, finally the stripped list is then passed to ‘x*2’ where a new list is generated from the previous list x being mapped to x*2.</p>

<p>A better example:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">square</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">\*\*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>

<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">square</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span></code></pre></figure>

<h4 id="tuples">TUPLES</h4>
<p>Tuples are a little bit like lists in that they store sets of data, however they differ in fundamental ways. Tuples store <em>heterogeneous</em> data and they cannot be extended in size. If you define a tuple to contain a <em>Char</em> and a <em>Bool</em> then it can only contains those 2 types in the correct order. Tuples are defined using the following notation:</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs"><span class="n">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="s">"Hi"</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">tuple</span>
<span class="p">(</span><span class="s">"Hi"</span><span class="p">,</span> <span class="kt">True</span><span class="p">)</span></code></pre></figure>

<p><em>(“Hi”, True)”</em> isn’t the same type of tuple as <em>(True, “Hi”)</em>, order is important.</p>

<p>Because tuples composed of 2 types of data are dealt with so frequently there are 2 important functions to memorise: <em>fst</em> and <em>snd</em>, they’re fairly obvious:</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs"><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="p">(</span><span class="s">"one"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="s">"one"</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">snd</span> <span class="p">(</span><span class="s">"one"</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> 
<span class="mi">2</span></code></pre></figure>

<p>A list of tuples can be produced using the <em>zip</em> command that takes 2 lists as parameters and creates pairs based on those lists:</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs"><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="p">[</span><span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">,</span> <span class="s">"three"</span><span class="p">,</span> <span class="s">"four"</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="s">"one"</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">"two"</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">"three"</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s">"four"</span><span class="p">)]</span></code></pre></figure>

<p>Tuples, as any other primitive can be used in list comprehension, they’re useful for calculating things:</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs"><span class="n">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">triangle</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="o">==</span><span class="mi">24</span><span class="p">,</span> <span class="n">a</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span><span class="o">==</span><span class="n">c</span><span class="o">^</span><span class="mi">2</span> <span class="p">]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">triangle</span>
<span class="p">[(</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span></code></pre></figure>

<p>This is a simple function that calculates the sides of a triangle such that:</p>
<ul>
  <li>Perimeter = 24</li>
  <li>Right angled</li>
  <li>Integer sides</li>
</ul>

<p>The predicates are evaluated in the order they’re written in (DON’T UNDERSTAND WHY THEY’RE IN THAT ORDER TO AVOID (a OR b) &gt; c)</p>

      </section>
    </div>

    <script type="text/javascript">
      $(document).ready(function() {
        $('.toc').toc();
      });
    </script>
  </body>
</html>
