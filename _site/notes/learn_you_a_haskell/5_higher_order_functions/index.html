<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

	<!-- Basic Page Needs
  ================================================== -->
  <title>Higher Order Functions</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="author" content="Will Price" />
  <link href="http://feeds.feedburner.com/willpriceblog" type="application/atom+xml" title="Will Price" rel="alternative"/>
	<meta name="description" content="">
	<meta name="author" content="">

	<!-- Mobile Specific Metas
  ================================================== -->
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<!-- CSS
  ================================================== -->
	<link rel="stylesheet" href="/css/base.css">
	<link rel="stylesheet" href="/css/skeleton.css">
  <link rel="stylesheet" href="/css/layout.css">
	<link rel="stylesheet" href="/css/user.css">
	<link rel="stylesheet" href="/css/pygments.css">
  <link href='http://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>

  <! -- SCRIPTS
  ================================================== -->
  <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script type="text/javascript" src="/scripts/toc.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-41410283-1', 'willprice.org');
    ga('send', 'pageview');
  </script>
  


	<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<!-- Favicons
	================================================== -->
	<link rel="shortcut icon" href="images/favicon.ico">
	<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">

</head>
<body>



	<!-- Primary Page Layout
	================================================== -->

	<!-- Delete everything in this .container and get started on your own site! -->

	<div class="container">
		<div class="sixteen columns">
      <div class="title">
        <a href="/">Will Price</a>
        <a class="extra" href="/posts.html">Posts</a>
        <a class="extra" href="/about.html">About</a>
        <hr />
      </div>

      <section>
      <p>When passing a function (f1) as a parameter to another function (f2), then f2 is a higher order function. Bizarrely every function in Haskell officially only takes one parameter :O! When you’re using a function that takes more than one parameter, what happens is the first parameter is evaluated, the function returns ANOTHER function, which then takes the second parameter and creates another function which is then applied to the 3rd parameter and so on…</p>

<p>Functions that only take one parameter are called curried functions.</p>

<p>Infix functions can be turned into prefix functions by surrounding them by parentheses, this is called a <em>section</em> (like the analog of putting back ticks around prefix functions turning them into infix functions)</p>

<p>Partial functions can be written like so <code class="highlighter-rouge">(/10) 9</code> or <code class="highlighter-rouge">(max 9) 1</code></p>

<p>Functions aren’t members of <em>Show</em> so they cannot be printed to the screen in a nice string format (which would be very cool.</p>

<p>Example of higher order function:</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs">  <span class="n">addThree</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span>
  <span class="n">applyTwice</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">applyTwice</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>

  <span class="o">...</span>

<span class="kt">Prelude</span><span class="o">&gt;</span>  <span class="n">applyTwice</span> <span class="n">addThree</span> <span class="mi">2</span>
<span class="mi">8</span>
<span class="n">prelude</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="mi">1</span> <span class="c1">-- remember that (+1) is a sectioned function, and therefore (+1) :: (Num a) =&gt; a -&gt; a</span>
<span class="mi">3</span></code></pre></figure>

<p>Some more interesting functions:</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs">  <span class="n">filter'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
  <span class="n">filter'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
  <span class="n">filter'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">filter'</span> <span class="n">f</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">filter'</span> <span class="n">f</span> <span class="n">xs</span>

  <span class="n">flip'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span>
  <span class="n">flip'</span> <span class="n">f</span> <span class="o">=</span> <span class="n">g</span>
    <span class="kr">where</span> <span class="n">g</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span>

  <span class="n">map'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
  <span class="n">map'</span> <span class="n">f</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
  <span class="n">map'</span> <span class="n">f</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span><span class="o">:</span><span class="kt">[]</span>
  <span class="n">map'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">map'</span> <span class="n">f</span> <span class="n">xs</span></code></pre></figure>

<p>Let’s code a function that will generate a Collatz chain from a starting number. A Collatz chain is defined:</p>

<ul>
  <li>start with any natural number</li>
  <li>if the number is 1, stop</li>
  <li>if the number is even, divide it by 2</li>
  <li>if the number is odd, multiply it by 3 and add 1</li>
  <li>repeat the algorithm with the resulting number</li>
</ul>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs">  <span class="n">collatz</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
  <span class="n">collatz</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span>      <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="o">|</span> <span class="n">even</span> <span class="n">a</span>      <span class="o">=</span> <span class="n">a</span><span class="o">:</span><span class="n">collatz</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">odd</span> <span class="n">a</span>       <span class="o">=</span> <span class="n">a</span><span class="o">:</span><span class="n">collatz</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">otherwise</span>   <span class="o">=</span> <span class="kt">[]</span></code></pre></figure>

<p>Remember that <code class="highlighter-rouge">div</code> must be used for Integral division, otherwise a Rational number will be the result, which can’t be used with <code class="highlighter-rouge">even</code> and <code class="highlighter-rouge">odd</code>.
# Folds
Folds are pretty cool, they allow you to apply a binary function to every member in the list starting with the first and second value, then the result of that and the third value and so on, the starting value is called the <em>accumulator</em>.</p>

<p>Folds deal with reducing a data structure down into a single value, this is carried out through a recursive process</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs">  <span class="c1">-- Definition of foldl' (fold left)</span>
  <span class="n">foldl'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">foldl'</span> <span class="n">f</span> <span class="n">acc</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span> <span class="n">acc</span> <span class="n">x</span>
  <span class="n">foldl'</span> <span class="n">f</span> <span class="n">acc</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">foldl'</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">acc</span> <span class="n">x</span><span class="p">)</span> <span class="n">xs</span></code></pre></figure>

<p>Implementing the sum function can be done recursively or with foldl:</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs">  <span class="c1">-- recursive definition</span>
  <span class="n">sum'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span> <span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">sum'</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="c1">-- base case</span>
  <span class="n">sum'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span> <span class="n">xs</span>
  
  <span class="c1">-- foldl definition</span>
  <span class="n">sum'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
  <span class="n">sum'</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="n">xs</span></code></pre></figure>

<p><code class="highlighter-rouge">foldr</code> is similar to <code class="highlighter-rouge">foldl</code> but starts from the right, rather than the left and it has a different syntax:
<code class="highlighter-rouge">foldl &lt;binary function&gt; &lt;initial accumulator val&gt; &lt;list&gt;</code>, the binary function (f) will be applied like so: <code class="highlighter-rouge">f acc x</code> where <code class="highlighter-rouge">x</code> is the current val being read from the list, and <code class="highlighter-rouge">acc</code> is the accumulator.</p>

<p>Looking back at <code class="highlighter-rouge">foldr</code> you apply it in the same way as <code class="highlighter-rouge">foldl</code>: <code class="highlighter-rouge">foldr &lt;binary function&gt; &lt;initial accumulator val&gt; &lt;list&gt;</code>, however, when the binary function is evaluated, it’s parameters are flipped: <code class="highlighter-rouge">f x acc</code>. This might seem confusing at first, but there’s logic to it: when you’re reading a list from the right, you’re going right to left, so the accumulator is generate from all the stuff you’ve just read, which is on the right, whereas when you’re reading a list from the left, all the stuff you’ve read was on the left, hence why the accumulator comes first!</p>

<h1 id="lambda-functions">Lambda functions</h1>
<p>Anonymous functions are simply functions that don’t have a name, these are especially useful when dealing with higher order functions, as instead of writing a separate simple function, you can integrate it with function call. Let’s have a look at an example where we define a separate function and the corresponding use of a lambda function. First off, lambdas are defined using <code class="highlighter-rouge">(\&lt;arguments&gt; -&gt; &lt;function body&gt;)</code>, arguments are separated using commas, <code class="highlighter-rouge">\</code> simply says we’re now defining a lambda function, the brackets just hold everything together.</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs">  <span class="c1">-- Using a where definition</span>
  <span class="n">reverse</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">foldl</span> <span class="n">appendList</span> <span class="kt">[]</span> <span class="n">xs</span>
    <span class="kr">where</span> <span class="n">appendList</span> <span class="n">acc</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span><span class="n">acc</span>

  <span class="c1">-- Using a lambda function</span>
  <span class="n">reverse</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">:</span><span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">xs</span></code></pre></figure>

<h1 id="syntactical-beauty">Syntactical beauty</h1>
<p>## Function application with <code class="highlighter-rouge">$</code></p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs">  <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span>
  <span class="n">f</span> <span class="o">$</span> <span class="n">a</span> <span class="o">=</span> <span class="n">f</span> <span class="n">a</span></code></pre></figure>

<p>Yes, that’s right, this does not modify the function at all. However it changes how an expression with <code class="highlighter-rouge">$</code> is evaluated, <code class="highlighter-rouge">f $ a + 4</code> would be evaluated as <code class="highlighter-rouge">f (a+4)</code>, <code class="highlighter-rouge">$</code> has the lowest precedence of all operators. This allows you to write code a little more cleanly without so many parentheses. For example: <code class="highlighter-rouge">sum (map (*2) [1..10])</code> becomes <code class="highlighter-rouge">sum $ map (*2) [1..10]</code>.  It also allows you to weird things like <code class="highlighter-rouge">map ($ 3) [(4+), (4*), (4/)]</code> strange, eh?</p>

<h2 id="function-composition">Function composition</h2>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs">  <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
  <span class="n">f</span> <span class="o">.</span> <span class="n">g</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span></code></pre></figure>

<p>Yay, more abstraction! Cool things like <code class="highlighter-rouge">map (negate . abs) [1, -2, -4, 3]</code> are now possible. So function composition takes 2 functions and returns a composite function which can then be combined with more functions to make more complex composite functions f(g(h(i(x))))) == f . g . h . i, much tidier, and no nasty parentheses!</p>

<p>Note: Function composition is right associate, that is: <code class="highlighter-rouge">sum . tail</code> == <code class="highlighter-rouge">sum (tail)</code></p>

<p>What about using functions that take multiple parameters? well how about…</p>

<figure class="highlight"><pre><code class="language-hs" data-lang="hs">  <span class="c1">-- not too tidy</span>
  <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">5</span> <span class="p">(</span><span class="n">max</span> <span class="n">x</span> <span class="n">y</span><span class="p">))</span>
  
  <span class="c1">-- much better!</span>
  <span class="n">f'</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">replicate</span> <span class="o">$</span> <span class="n">max</span> <span class="n">x</span> <span class="n">y</span></code></pre></figure>


      </section>
    </div>
    <script type="text/javascript">
      $(document).ready(function() {
        $('.toc').toc();
      });
    </script>
  </div>
  <!-- container -->


<!-- End Document
================================================== -->
</body>
</html>
